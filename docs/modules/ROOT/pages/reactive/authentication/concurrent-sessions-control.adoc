[[reactive-concurrent-sessions-control]]
= Concurrent Sessions Control

Similar to xref:servlet/authentication/session-management.adoc#ns-concurrent-sessions[Servlet's Concurrent Sessions Control], Spring Security also provides support to limit the number of concurrent sessions a user can have in a Reactive application.

When you set up Concurrent Sessions Control in Spring Security, it monitors authentications carried out through Form Login, xref:reactive/oauth2/login/index.adoc[OAuth 2.0 Login], and HTTP Basic authentication by hooking into the way those authentication mechanisms handle authentication success.
More specifically, the session management DSL will add the {security-api-url}org/springframework/security/web/server/authentication/RegisterSessionServerAuthenticationSuccessHandler.html[RegisterSessionServerAuthenticationSuccessHandler] to the list of `ServerAuthenticationSuccessHandler` used by the authentication filter.

The following sections contains examples of how to configure Concurrent Sessions Control.

* <<reactive-concurrent-sessions-control-limit,I want to limit the number of concurrent sessions a user can have>>
* <<concurrent-sessions-control-custom-strategy,I want to customize the strategy used when the maximum number of sessions is exceeded>>
* <<reactive-concurrent-sessions-control-specify-session-registry,I want to know how to specify a `ReactiveSessionRegistry`>>
* <<concurrent-sessions-control-sample,I want to see a sample application that uses Concurrent Sessions Control>>
* <<disabling-for-authentication-filters,I want to know how to disable it for some authentication filter>>

[[reactive-concurrent-sessions-control-limit]]
== Limiting Concurrent Sessions

By default, Spring Security will allow any number of concurrent sessions for a user.
To limit the number of concurrent sessions, you can use the `maximumSessions` DSL method:

.Configuring one session for any user
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain filterChain(ServerHttpSecurity http) {
    http
        // ...
        .sessionManagement((sessions) -> sessions
            .concurrentSessions((concurrency) -> concurrency
                .maximumSessions(SessionLimit.of(1)))
        );
    return http.build();
}

@Bean
ReactiveSessionRegistry reactiveSessionRegistry() {
    ReactiveMaximumSessionsExceededHandler handler = new PreventLoginReactiveMaximumSessionsExceededHandler();
    return new InMemoryReactiveSessionRegistry(handler);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        sessionManagement {
            sessionConcurrency {
                maximumSessions = SessionLimit.of(1)
            }
        }
    }
}

@Bean
open fun reactiveSessionRegistry(): ReactiveSessionRegistry {
    val handler = PreventLoginReactiveMaximumSessionsExceededHandler()
    return InMemoryReactiveSessionRegistry(handler)
}
----
======

The above configuration allows one session for any user.
Similarly, you can also allow unlimited sessions by using the `SessionLimit#UNLIMITED` constant:

.Configuring unlimited sessions
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain filterChain(ServerHttpSecurity http) {
    http
        // ...
        .sessionManagement((sessions) -> sessions
            .concurrentSessions((concurrency) -> concurrency
                .maximumSessions(SessionLimit.UNLIMITED))
        );
    return http.build();
}

@Bean
ReactiveSessionRegistry reactiveSessionRegistry() {
    ReactiveMaximumSessionsExceededHandler handler = new PreventLoginReactiveMaximumSessionsExceededHandler();
    return new InMemoryReactiveSessionRegistry(handler);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        sessionManagement {
            sessionConcurrency {
                maximumSessions = SessionLimit.UNLIMITED
            }
        }
    }
}

@Bean
open fun reactiveSessionRegistry(): ReactiveSessionRegistry {
    val handler = PreventLoginReactiveMaximumSessionsExceededHandler()
    return InMemoryReactiveSessionRegistry(handler)
}
----
======

Since the `maximumSessions` method accepts a `SessionLimit` interface, which in turn extends `Function<Authentication, Mono<Integer>>`, you can have a more complex logic to determine the maximum number of sessions based on the user's authentication:

.Configuring maximumSessions based on `Authentication`
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain filterChain(ServerHttpSecurity http) {
    http
        // ...
        .sessionManagement((sessions) -> sessions
            .concurrentSessions((concurrency) -> concurrency
                .maximumSessions(maxSessions()))
        );
    return http.build();
}

private SessionLimit maxSessions() {
    return (authentication) -> {
        if (authentication.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_UNLIMITED_SESSIONS"))) {
            return Mono.empty(); // allow unlimited sessions for users with ROLE_UNLIMITED_SESSIONS
        }
        if (authentication.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"))) {
            return Mono.just(2); // allow two sessions for admins
        }
        return Mono.just(1); // allow one session for every other user
    };
}

@Bean
ReactiveSessionRegistry reactiveSessionRegistry() {
    ReactiveMaximumSessionsExceededHandler handler = new PreventLoginReactiveMaximumSessionsExceededHandler();
    return new InMemoryReactiveSessionRegistry(handler);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        sessionManagement {
            sessionConcurrency {
                maximumSessions = maxSessions()
            }
        }
    }
}

fun maxSessions(): SessionLimit {
    return { authentication ->
        if (authentication.authorities.contains(SimpleGrantedAuthority("ROLE_UNLIMITED_SESSIONS"))) Mono.empty
        if (authentication.authorities.contains(SimpleGrantedAuthority("ROLE_ADMIN"))) Mono.just(2)
        Mono.just(1)
    }
}

@Bean
open fun reactiveSessionRegistry(webSessionManager: DefaultWebSessionManager): ReactiveSessionRegistry {
    val handler = PreventLoginReactiveMaximumSessionsExceededHandler()
    return InMemoryReactiveSessionRegistry(handler)
}
----
======

With the above configurations you configured the maximum number of sessions a user can have based on their authentication.
Let's go ahead to the next section to see how to <<concurrent-sessions-control-custom-strategy,customize the strategy used when the maximum number of sessions is exceeded>>.

[[concurrent-sessions-control-custom-strategy]]
== Handling Maximum Number of Sessions Exceeded

In the <<reactive-concurrent-sessions-control-limit,examples above>>, we configured the `InMemoryReactiveSessionRegistry` bean by passing a `ReactiveMaximumSessionsExceededHandler` to its constructor.
The `InMemoryReactiveSessionRegistry`, extends the `AbstractConcurrencyControlReactivePrincipalSessionRegistry` which is an abstract implementation of `ReactiveSessionRegistry` that checks the maximum number of sessions allowed when a `ReactiveSessionInformation` is saved.
If the maximum number of sessions is exceeded, the `ReactiveMaximumSessionsExceededHandler` is called.

Spring Security provides two implementations of `ReactiveMaximumSessionsExceededHandler` that you can use to handle when the maximum number of sessions exceeds, those are the {security-api-url}org/springframework/security/web/server/authentication/InvalidateLeastUsedReactiveMaximumSessionsExceededHandler.html[InvalidateLeastUsedReactiveMaximumSessionsExceededHandler] and {security-api-url}org/springframework/security/web/server/authentication/PreventLoginReactiveMaximumSessionsExceededHandler.html[PreventLoginReactiveMaximumSessionsExceededHandler].
However, you are not limited to those implementations, you can always provide your own by creating a class that implements `ReactiveMaximumSessionsExceededHandler`.
The `InvalidateLeastUsedReactiveMaximumSessionsExceededHandler` will invalidate the least recently used sessions against the `WebSessionStore`, while the `PreventLoginReactiveMaximumSessionsExceededHandler` will prevent the user from logging in.

.Configuring maximumSessionsExceededHandler
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain filterChain(ServerHttpSecurity http) {
    http
        // ...
        .sessionManagement((sessions) -> sessions
            .concurrentSessions((concurrency) -> concurrency
                .maximumSessions(SessionLimit.of(1))
            )
        );
    return http.build();
}

@Bean
ReactiveSessionRegistry reactiveSessionRegistry(WebSessionManager webSessionManager) {
    WebSessionStore sessionStore = ((DefaultWebSessionManager) webSessionManager).getSessionStore();
    ReactiveMaximumSessionsExceededHandler handler = new InvalidateLeastUsedReactiveMaximumSessionsExceededHandler(sessionStore);
    return new InMemoryReactiveSessionRegistry(handler);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        sessionManagement {
            sessionConcurrency {
                maximumSessions = SessionLimit.of(1)
            }
        }
    }
}

@Bean
open fun reactiveSessionRegistry(webSessionManager: WebSessionManager): ReactiveSessionRegistry {
    val sessionStore = (webSessionManager as DefaultWebSessionManager).sessionStore
    val handler = InvalidateLeastUsedReactiveMaximumSessionsExceededHandler(sessionStore)
    return InMemoryReactiveSessionRegistry(handler)
}
----
======

[NOTE]
====
When creating the `InvalidateLeastUsedReactiveMaximumSessionsExceededHandler`, you need to provide the `WebSessionStore` that is being used by your application.
If you are using Spring WebFlux, you can use the `WebSessionManager` bean (which is usually an instance of `DefaultWebSessionManager`) to get the `WebSessionStore`.
====

[[reactive-concurrent-sessions-control-specify-session-registry]]
== Specifying a `ReactiveSessionRegistry`

In order to keep track of the user's sessions, Spring Security uses a {security-api-url}org/springframework/security/core/session/ReactiveSessionRegistry.html[ReactiveSessionRegistry], and, every time a user logs in, their session information is saved.
There is also the {security-api-url}org/springframework/security/core/session/AbstractConcurrencyControlReactivePrincipalSessionRegistry.html[AbstractConcurrencyControlReactivePrincipalSessionRegistry] which is an abstract implementation of `ReactiveSessionRegistry` that checks the maximum number of sessions allowed when a `ReactiveSessionInformation` is saved.

Spring Security ships with a {security-api-url}org/springframework/security/core/session/InMemoryReactiveSessionRegistry.html[InMemoryReactiveSessionRegistry] implementation that extends `AbstractConcurrencyControlReactivePrincipalSessionRegistry`.

To specify a `ReactiveSessionRegistry` implementation you can either declare it as a bean:

.ReactiveSessionRegistry as a Bean
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain filterChain(ServerHttpSecurity http) {
    http
        // ...
        .sessionManagement((sessions) -> sessions
            .concurrentSessions((concurrency) -> concurrency
                .maximumSessions(SessionLimit.of(1))
            )
        );
    return http.build();
}

@Bean
ReactiveSessionRegistry reactiveSessionRegistry() {
    ReactiveMaximumSessionsExceededHandler handler = new MyHandler();
    return new InMemoryReactiveSessionRegistry(handler);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        sessionManagement {
            sessionConcurrency {
                maximumSessions = SessionLimit.of(1)
            }
        }
    }
}

@Bean
open fun reactiveSessionRegistry(): ReactiveSessionRegistry {
    val handler: ReactiveMaximumSessionsExceededHandler = MyHandler()
    return InMemoryReactiveSessionRegistry(handler)
}
----
======

or you can use the `sessionRegistry` DSL method:

.ReactiveSessionRegistry using sessionRegistry DSL method
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain filterChain(ServerHttpSecurity http) {
    http
        // ...
        .sessionManagement((sessions) -> sessions
            .concurrentSessions((concurrency) -> concurrency
                .maximumSessions(SessionLimit.of(1))
                .sessionRegistry(new InMemoryReactiveSessionRegistry(new MyHandler()))
            )
        );
    return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        sessionManagement {
            sessionConcurrency {
                maximumSessions = SessionLimit.of(1)
                sessionRegistry = InMemoryReactiveSessionRegistry(MyHandler())
            }
        }
    }
}
----
======

[[disabling-for-authentication-filters]]
== Disabling It for Some Authentication Filters

By default, Concurrent Sessions Control will be configured automatically for Form Login, OAuth 2.0 Login, and HTTP Basic authentication as long as they do not specify an `ServerAuthenticationSuccessHandler` themselves.
For example, the following configuration will disable Concurrent Sessions Control for Form Login:

.Disabling Concurrent Sessions Control for Form Login
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain filterChain(ServerHttpSecurity http) {
    http
        // ...
        .formLogin((login) -> login
            .authenticationSuccessHandler(new RedirectServerAuthenticationSuccessHandler("/"))
        )
        .sessionManagement((sessions) -> sessions
            .concurrentSessions((concurrency) -> concurrency
                .maximumSessions(SessionLimit.of(1))
            )
        );
    return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        formLogin {
            authenticationSuccessHandler = RedirectServerAuthenticationSuccessHandler("/")
        }
        sessionManagement {
            sessionConcurrency {
                maximumSessions = SessionLimit.of(1)
            }
        }
    }
}
----
======

=== Adding Additional Success Handlers Without Disabling Concurrent Sessions Control

You can also include additional `ServerAuthenticationSuccessHandler` instances to the list of handlers used by the authentication filter without disabling Concurrent Sessions Control.
To do that you can use the `authenticationSuccessHandler(Consumer<List<ServerAuthenticationSuccessHandler>>)` method:

.Adding additional handlers
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain filterChain(ServerHttpSecurity http) {
    http
        // ...
        .formLogin((login) -> login
            .authenticationSuccessHandler((handlers) -> handlers.add(new MyAuthenticationSuccessHandler()))
        )
        .sessionManagement((sessions) -> sessions
            .concurrentSessions((concurrency) -> concurrency
                .maximumSessions(SessionLimit.of(1))
            )
        );
    return http.build();
}
----
======

[[concurrent-sessions-control-sample]]
== Checking a Sample Application

You can check the {gh-samples-url}/reactive/webflux/java/session-management/maximum-sessions[sample application here].
